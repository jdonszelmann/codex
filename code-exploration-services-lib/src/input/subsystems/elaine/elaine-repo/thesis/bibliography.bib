
@incollection{oh_latent_2021,
	location = {Cham},
	title = {Latent Effects for Reusable Language Components},
	volume = {13008},
	isbn = {978-3-030-89050-6 978-3-030-89051-3},
	url = {https://link.springer.com/10.1007/978-3-030-89051-3_11},
	abstract = {The development of programming languages can be quite complicated and costly. Hence, much eﬀort has been devoted to the modular deﬁnition of language features that can be reused in various combinations to deﬁne new languages and experiment with their semantics. A notable outcome of these eﬀorts is the algebra-based “datatypes `a la carte” ({DTC}) approach. When combined with algebraic eﬀects, {DTC} can model a wide range of common language features. Unfortunately, the current state of the art does not cover modular deﬁnitions of advanced control-ﬂow mechanisms that defer execution to an appropriate point, such as call-by-name and call-by-need evaluation, as well as (multi-)staging.},
	pages = {182--201},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer International Publishing},
	author = {van den Berg, Birthe and Schrijvers, Tom and Poulsen, Casper Bach and Wu, Nicolas},
	editor = {Oh, Hakjoo},
	urldate = {2023-01-12},
	date = {2021},
	langid = {english},
	doi = {10.1007/978-3-030-89051-3_11},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {van den Berg et al. - 2021 - Latent Effects for Reusable Language Components.pdf:/home/terts/Zotero/storage/42VDRB3D/van den Berg et al. - 2021 - Latent Effects for Reusable Language Components.pdf:application/pdf},
}

@incollection{swierstra_towards_2022,
	location = {Cham},
	title = {Towards a Language for Defining Reusable Programming Language Components: (Project Paper)},
	volume = {13401},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4_2},
	shorttitle = {Towards a Language for Defining Reusable Programming Language Components},
	abstract = {Developing programming languages is a diﬃcult task that requires a lot of time, eﬀort, and expertise. Reusable programming language components make this task easier, by allowing language designers to grab oﬀ-the-shelf components for common language features. Modern functional programming languages, however, lack support for reuse of deﬁnitions, and thus language components deﬁned using algebraic data types and pattern matching functions cannot be reused without modifying or copying existing code. To improve the situation, we introduce {CS}, a functional meta-language for developing reusable programming language components, that features built-in support for extensible data types and functions, as well as eﬀects and handlers. In {CS}, we can deﬁne language components using algebraic data types and pattern matching functions, such that we can compose language components into larger languages and deﬁne new interpretations for existing components without modifying existing deﬁnitions.},
	pages = {18--38},
	booktitle = {Trends in Functional Programming},
	publisher = {Springer International Publishing},
	author = {van der Rest, Cas and Poulsen, Casper Bach},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	urldate = {2023-01-12},
	date = {2022},
	langid = {english},
	doi = {10.1007/978-3-031-21314-4_2},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {van der Rest and Poulsen - 2022 - Towards a Language for Defining Reusable Programmi.pdf:/home/terts/Zotero/storage/MYYD7MQA/van der Rest and Poulsen - 2022 - Towards a Language for Defining Reusable Programmi.pdf:application/pdf},
}

@misc{van_der_rest_handling_2022,
	title = {Handling Higher-Order Effects},
	url = {http://arxiv.org/abs/2203.03288},
	abstract = {Algebraic effect handlers is a programming paradigm where programmers can declare their own syntactic operations, and modularly define the semantics of these using effect handlers. However, we cannot directly define algebraic effect handlers for many higher-order operations (or higher-order effects) -- i.e., operations that have computations as parameters. Examples of such higher-order effects include common programming features, such as try-catch exception handlers, function abstraction, and more. In this paper we present a new kind of effect handler that addresses this shortcoming. Our effect handler approach is closely related to previous work on scoped effect handlers, which also supports higher-order effects. A key difference is that our effect handlers make it easy to understand separate (higher-order) effects as separate concerns, since effects do not interact. In contrast, effect interaction is the default with scoped effect handlers. While separate concerns is the default with our handlers, it is also possible to define handlers where effects interact.},
	number = {{arXiv}:2203.03288},
	publisher = {{arXiv}},
	author = {van der Rest, Cas and Reinders, Jaro and Poulsen, Casper Bach},
	urldate = {2023-01-12},
	date = {2022-03-07},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2203.03288 [cs]},
	keywords = {Computer Science - Programming Languages, F.3.2},
	file = {van der Rest et al. - 2022 - Handling Higher-Order Effects.pdf:/home/terts/Zotero/storage/WTQMFDSS/van der Rest et al. - 2022 - Handling Higher-Order Effects.pdf:application/pdf},
}

@incollection{drossopoulou_sound_2008,
	location = {Berlin, Heidelberg},
	title = {A Sound Semantics for {OCaml} light},
	volume = {4960},
	isbn = {978-3-540-78738-9 978-3-540-78739-6},
	url = {http://link.springer.com/10.1007/978-3-540-78739-6_1},
	abstract = {Few programming languages have a mathematically rigorous deﬁnition or metatheory—in part because they are perceived as too large and complex to work with. This paper demonstrates the feasibility of such undertakings: we formalize a substantial portion of the semantics of Objective Caml’s core language (which had not previously been given a formal semantics), and we develop a mechanized type soundness proof in {HOL}. We also develop an executable version of the operational semantics, verify that it coincides with our semantic definition, and use it to test conformance between the semantics and the {OCaml} implementation. We intend our semantics to be a suitable substrate for the veriﬁcation of {OCaml} programs.},
	pages = {1--15},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Owens, Scott},
	editor = {Drossopoulou, Sophia},
	urldate = {2023-01-12},
	date = {2008},
	langid = {english},
	doi = {10.1007/978-3-540-78739-6_1},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Owens - 2008 - A Sound Semantics for OCaml light.pdf:/home/terts/Zotero/storage/ZHK3FQJ2/Owens - 2008 - A Sound Semantics for OCaml light.pdf:application/pdf},
}

@article{moggi_notions_1991,
	title = {Notions of computation and monads},
	volume = {93},
	issn = {08905401},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0890540191900524},
	doi = {10.1016/0890-5401(91)90052-4},
	pages = {55--92},
	number = {1},
	journaltitle = {Information and Computation},
	shortjournal = {Information and Computation},
	author = {Moggi, Eugenio},
	urldate = {2023-01-12},
	date = {1991-07},
	langid = {english},
	file = {Moggi - 1991 - Notions of computation and monads.pdf:/home/terts/Zotero/storage/Q6F6S9LG/Moggi - 1991 - Notions of computation and monads.pdf:application/pdf},
}

@article{plotkin_handling_2013,
	title = {Handling Algebraic Effects},
	volume = {9},
	issn = {18605974},
	url = {https://lmcs.episciences.org/705},
	doi = {10.2168/LMCS-9(4:23)2013},
	abstract = {Algebraic eﬀects are computational eﬀects that can be represented by an equational theory whose operations produce the eﬀects at hand. The free model of this theory induces the expected computational monad for the corresponding eﬀect. Algebraic eﬀects include exceptions, state, nondeterminism, interactive input/output, and time, and their combinations. Exception handling, however, has so far received no algebraic treatment.},
	pages = {23},
	number = {4},
	journaltitle = {Logical Methods in Computer Science},
	shortjournal = {Log.Meth.Comput.Sci.},
	author = {Plotkin, Gordon and Pretnar, Matija},
	editor = {Tarlecki, Andrzej},
	urldate = {2023-01-12},
	date = {2013-12-17},
	langid = {english},
	file = {Plotkin and Pretnar - 2013 - Handling Algebraic Effects.pdf:/home/terts/Zotero/storage/Z63I7A89/Plotkin and Pretnar - 2013 - Handling Algebraic Effects.pdf:application/pdf},
}

@misc{wu_effect_2014,
	title = {Effect Handlers in Scope},
	abstract = {Algebraic effect handlers are a powerful means for describing effectful computations. They provide a lightweight and orthogonal technique to define and compose the syntax and semantics of different effects. The semantics is captured by handlers, which are functions that transform syntax trees. Unfortunately, the approach does not support syntax for scoping constructs, which arise in a number of scenarios. While handlers can be used to provide a limited form of scope, we demonstrate that this approach constrains the possible interactions of effects and rules out some desired semantics. This paper presents two different ways to capture scoped constructs in syntax, and shows how to achieve different semantics by reordering handlers. The first approach expresses scopes using the existing algebraic handlers framework, but has some limitations. The problem is fully solved in the second approach where we introduce higher-order syntax.},
	author = {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
	date = {2014-06-10},
	file = {Wu et al. - 2014 - Effect Handlers in Scope.pdf:/home/terts/Zotero/storage/Y2CYJ9RV/Wu et al. - 2014 - Effect Handlers in Scope.pdf:application/pdf},
}

@article{pretnar_introduction_2015,
	title = {An Introduction to Algebraic Effects and Handlers. Invited tutorial paper},
	volume = {319},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066115000705},
	doi = {10.1016/j.entcs.2015.12.003},
	abstract = {This paper is a tutorial on algebraic eﬀects and handlers. In it, we explain what algebraic eﬀects are, give ample examples to explain how handlers work, deﬁne an operational semantics and a type \& eﬀect system, show how one can reason about eﬀects, and give pointers for further reading.},
	pages = {19--35},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Pretnar, Matija},
	urldate = {2023-01-12},
	date = {2015-12},
	langid = {english},
	file = {Pretnar - 2015 - An Introduction to Algebraic Effects and Handlers..pdf:/home/terts/Zotero/storage/6JHDDVP8/Pretnar - 2015 - An Introduction to Algebraic Effects and Handlers..pdf:application/pdf},
}

@inproceedings{kammar_handlers_2013,
	location = {Boston Massachusetts {USA}},
	title = {Handlers in action},
	isbn = {978-1-4503-2326-0},
	url = {https://dl.acm.org/doi/10.1145/2500365.2500590},
	doi = {10.1145/2500365.2500590},
	eventtitle = {{ICFP}'13: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {145--158},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {{ACM}},
	author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
	urldate = {2023-01-18},
	date = {2013-09-25},
	langid = {english},
	file = {Kammar et al. - 2013 - Handlers in action.pdf:/home/terts/Zotero/storage/NTEZTXGD/Kammar et al. - 2013 - Handlers in action.pdf:application/pdf},
}

@article{bach_poulsen_hefty_2023,
	title = {Hefty Algebras: Modular Elaboration of Higher-Order Algebraic Effects},
	volume = {7},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3571255},
	doi = {10.1145/3571255},
	shorttitle = {Hefty Algebras},
	abstract = {Algebraic effects and handlers is an increasingly popular approach to programming with effects. An attraction of the approach is its modularity: effectful programs are written against an interface of declared operations, which allows the implementation of these operations to be defined and refined without changing or recompiling programs written against the interface. However, higher-order operations (i.e., operations that take computations as arguments) break this modularity. While it is possible to encode higher-order operations by elaborating them into more primitive algebraic effects and handlers, such elaborations are typically not modular. In particular, operations defined by elaboration are typically not a part of any effect interface, so we cannot define and refine their implementation without changing or recompiling programs. To resolve this problem, a recent line of research focuses on developing new and improved effect handlers. In this paper we present a (surprisingly) simple alternative solution to the modularity problem with higher-order operations:  
we modularize the previously non-modular elaborations commonly used to encode higher-order operations. Our solution is as expressive as the state of the art in effects and handlers.},
	pages = {1801--1831},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Bach Poulsen, Casper and van der Rest, Cas},
	urldate = {2023-01-26},
	date = {2023-01-09},
	langid = {english},
	file = {Bach Poulsen and van der Rest - 2023 - Hefty Algebras Modular Elaboration of Higher-Orde.pdf:/home/terts/Zotero/storage/FEZCDW6F/Bach Poulsen and van der Rest - 2023 - Hefty Algebras Modular Elaboration of Higher-Orde.pdf:application/pdf},
}

@article{bauer_programming_2015,
	title = {Programming with algebraic effects and handlers},
	volume = {84},
	issn = {23522208},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S2352220814000194},
	doi = {10.1016/j.jlamp.2014.02.001},
	abstract = {Eff is a programming language based on the algebraic approach to computational effects, in which effects are viewed as algebraic operations and effect handlers as homomorphisms from free algebras. Eff supports ﬁrst-class effects and handlers through which we may easily deﬁne new computational effects, seamlessly combine existing ones, and handle them in novel ways. We give a denotational semantics of Eff and discuss a prototype implementation based on it. Through examples we demonstrate how the standard effects are treated in Eff, and how Eff supports programming techniques that use various forms of delimited continuations, such as backtracking, breadth-ﬁrst search, selection functionals, cooperative multi-threading, and others.},
	pages = {108--123},
	number = {1},
	journaltitle = {Journal of Logical and Algebraic Methods in Programming},
	shortjournal = {Journal of Logical and Algebraic Methods in Programming},
	author = {Bauer, Andrej and Pretnar, Matija},
	urldate = {2023-04-03},
	date = {2015-01},
	langid = {english},
	file = {Bauer and Pretnar - 2015 - Programming with algebraic effects and handlers.pdf:/home/terts/Zotero/storage/FW43SCRE/Bauer and Pretnar - 2015 - Programming with algebraic effects and handlers.pdf:application/pdf},
}

@thesis{pretnar_logic_2010,
	title = {The Logic and Handling of Algebraic Effects},
	institution = {The University of Edinburgh},
	type = {phdthesis},
	author = {Pretnar, Matija},
	date = {2010},
	langid = {english},
	file = {Pretnar - The Logic and Handling of Algebraic Effects.pdf:/home/terts/Zotero/storage/IMU34MMC/Pretnar - The Logic and Handling of Algebraic Effects.pdf:application/pdf},
}

@inproceedings{moggi_computational_1989,
	location = {Pacific Grove, {CA}, {USA}},
	title = {Computational lambda-calculus and monads},
	isbn = {978-0-8186-1954-0},
	url = {http://ieeexplore.ieee.org/document/39155/},
	doi = {10.1109/LICS.1989.39155},
	abstract = {The λ-calculus is considered an useful mathematical tool in the study of programming languages. However, if one uses βη-conversion to prove equivalence of programs, then a gross simpliﬁcation1 is introduced. We give a calculus based on a categorical semantics for computations, which provides a correct basis for proving equivalence of programs, independent from any speciﬁc computational model.},
	eventtitle = {[1989] Proceedings. Fourth Annual Symposium on Logic in Computer Science},
	pages = {14--23},
	booktitle = {[1989] Proceedings. Fourth Annual Symposium on Logic in Computer Science},
	publisher = {{IEEE} Comput. Soc. Press},
	author = {Moggi, Eugenio},
	urldate = {2023-04-08},
	date = {1989},
	langid = {english},
	file = {Moggi - 1989 - Computational lambda-calculus and monads.pdf:/home/terts/Zotero/storage/56LWTKNU/Moggi - 1989 - Computational lambda-calculus and monads.pdf:application/pdf},
}

@incollection{goos_adequacy_2001,
	location = {Berlin, Heidelberg},
	title = {Adequacy for Algebraic Effects},
	volume = {2030},
	isbn = {978-3-540-41864-1 978-3-540-45315-4},
	url = {http://link.springer.com/10.1007/3-540-45315-6_1},
	abstract = {Moggi proposed a monadic account of computational eﬀects. He also presented the computational λ-calculus, λc, a core call-by-value functional programming language for eﬀects; the eﬀects are obtained by adding appropriate operations. The question arises as to whether one can give a corresponding treatment of operational semantics. We do this in the case of algebraic eﬀects where the operations are given by a single-sorted algebraic signature, and their semantics is supported by the monad, in a certain sense. We consider call-by-value {PCF} with—and without—recursion, an extension of λc with arithmetic. We prove general adequacy theorems, and illustrate these with two examples: nondeterminism and probabilistic nondeterminism.},
	pages = {1--24},
	booktitle = {Foundations of Software Science and Computation Structures},
	publisher = {Springer Berlin Heidelberg},
	author = {Plotkin, Gordon and Power, John},
	editor = {Honsell, Furio and Miculan, Marino},
	editorb = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan},
	editorbtype = {redactor},
	urldate = {2023-04-08},
	date = {2001},
	langid = {english},
	doi = {10.1007/3-540-45315-6_1},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Plotkin and Power - 2001 - Adequacy for Algebraic Effects.pdf:/home/terts/Zotero/storage/BD3ME4NL/Plotkin and Power - 2001 - Adequacy for Algebraic Effects.pdf:application/pdf},
}

@incollection{castagna_handlers_2009,
	location = {Berlin, Heidelberg},
	title = {Handlers of Algebraic Effects},
	volume = {5502},
	isbn = {978-3-642-00589-3 978-3-642-00590-9},
	url = {http://link.springer.com/10.1007/978-3-642-00590-9_7},
	pages = {80--94},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Plotkin, Gordon and Pretnar, Matija},
	editor = {Castagna, Giuseppe},
	urldate = {2023-04-08},
	date = {2009},
	doi = {10.1007/978-3-642-00590-9_7},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Accepted Version:/home/terts/Zotero/storage/QSC9N5WD/Plotkin and Pretnar - 2009 - Handlers of Algebraic Effects.pdf:application/pdf},
}

@misc{lindley_be_2017,
	title = {Do be do be do},
	url = {http://arxiv.org/abs/1611.09259},
	abstract = {We explore the design and implementation of Frank, a strict functional programming language with a bidirectional effect type system designed from the ground up around a novel variant of Plotkin and Pretnar’s effect handler abstraction.},
	number = {{arXiv}:1611.09259},
	publisher = {{arXiv}},
	author = {Lindley, Sam and {McBride}, Conor and {McLaughlin}, Craig},
	urldate = {2023-04-08},
	date = {2017-10-03},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1611.09259 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {Lindley et al. - 2017 - Do be do be do.pdf:/home/terts/Zotero/storage/HVDS8XC9/Lindley et al. - 2017 - Do be do be do.pdf:application/pdf},
}

@inproceedings{leijen_type_2017,
	location = {Paris France},
	title = {Type directed compilation of row-typed algebraic effects},
	isbn = {978-1-4503-4660-3},
	url = {https://dl.acm.org/doi/10.1145/3009837.3009872},
	doi = {10.1145/3009837.3009872},
	eventtitle = {{POPL} '17: The 44th Annual {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	pages = {486--499},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Leijen, Daan},
	urldate = {2023-04-08},
	date = {2017-01},
	langid = {english},
	file = {Leijen - Type Directed Compilation of Row-Typed Algebraic E.pdf:/home/terts/Zotero/storage/GYJ3MYKX/Leijen - Type Directed Compilation of Row-Typed Algebraic E.pdf:application/pdf},
}

@inproceedings{sivaramakrishnan_retrofitting_2021,
	title = {Retrofitting Effect Handlers onto {OCaml}},
	url = {http://arxiv.org/abs/2104.00250},
	doi = {10.1145/3453483.3454039},
	abstract = {Effect handlers have been gathering momentum as a mechanism for modular programming with user-defined effects. Effect handlers allow for non-local control flow mechanisms such as generators, async/await, lightweight threads and coroutines to be composably expressed. We present a design and evaluate a full-fledged efficient implementation of effect handlers for {OCaml}, an industrial-strength multi-paradigm programming language. Our implementation strives to maintain the backwards compatibility and performance profile of existing {OCaml} code. Retrofitting effect handlers onto {OCaml} is challenging since {OCaml} does not currently have any nonlocal control flow mechanisms other than exceptions. Our implementation of effect handlers for {OCaml}: (i) imposes a mean 1\% overhead on a comprehensive macro benchmark suite that does not use effect handlers; (ii) remains compatible with program analysis tools that inspect the stack; and (iii) is efficient for new code that makes use of effect handlers.},
	pages = {206--221},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} International Conference on Programming Language Design and Implementation},
	author = {Sivaramakrishnan, K. C. and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
	urldate = {2023-04-08},
	date = {2021-06-19},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2104.00250 [cs]},
	keywords = {Computer Science - Programming Languages, D.3.3},
	file = {Sivaramakrishnan et al. - 2021 - Retrofitting Effect Handlers onto OCaml.pdf:/home/terts/Zotero/storage/GPMXK3JR/Sivaramakrishnan et al. - 2021 - Retrofitting Effect Handlers onto OCaml.pdf:application/pdf},
}

@article{nielsen_selective_2001,
	title = {A Selective {CPS} Transformation},
	volume = {45},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066104809691},
	doi = {10.1016/S1571-0661(04)80969-1},
	pages = {311--331},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Nielsen, Lasse R. and {Brics}},
	urldate = {2023-04-11},
	date = {2001-11},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/XGB3BL6B/Nielsen and Brics - 2001 - A Selective CPS Transformation.pdf:application/pdf},
}

@article{plotkin_call-by-name_1975,
	title = {Call-by-name, call-by-value and the λ-calculus},
	volume = {1},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0304397575900171},
	doi = {10.1016/0304-3975(75)90017-1},
	pages = {125--159},
	number = {2},
	journaltitle = {Theoretical Computer Science},
	shortjournal = {Theoretical Computer Science},
	author = {Plotkin, G.D.},
	urldate = {2023-04-11},
	date = {1975-12},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/RI4MEF3L/Plotkin - 1975 - Call-by-name, call-by-value and the λ-calculus.pdf:application/pdf},
}

@article{dijkstra_letters_1968,
	title = {Letters to the editor: go to statement considered harmful},
	volume = {11},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/362929.362947},
	doi = {10.1145/362929.362947},
	shorttitle = {Letters to the editor},
	pages = {147--148},
	number = {3},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Dijkstra, Edsger W.},
	urldate = {2023-05-31},
	date = {1968-03},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/CLTTGWP5/Dijkstra - 1968 - Letters to the editor go to statement considered .pdf:application/pdf},
}

@inproceedings{liang_monad_1995,
	location = {San Francisco, California, United States},
	title = {Monad transformers and modular interpreters},
	isbn = {978-0-89791-692-9},
	url = {http://portal.acm.org/citation.cfm?doid=199448.199528},
	doi = {10.1145/199448.199528},
	eventtitle = {the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium},
	pages = {333--343},
	booktitle = {Proceedings of the 22nd {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages  - {POPL} '95},
	publisher = {{ACM} Press},
	author = {Liang, Sheng and Hudak, Paul and Jones, Mark},
	urldate = {2023-06-01},
	date = {1995},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/J8EHEPCD/Liang et al. - 1995 - Monad transformers and modular interpreters.pdf:application/pdf},
}

@book{moggi_abstract_1989,
	title = {An Abstract View of Programming Languages},
	author = {Moggi, Eugenio},
	date = {1989},
	langid = {english},
	file = {Moggi - An Abstract View of Programming Languages.pdf:/home/terts/Zotero/storage/T8ZNS4V2/Moggi - An Abstract View of Programming Languages.pdf:application/pdf},
}

@article{brachthauser_effects_2020,
	title = {Effects as capabilities: effect handlers and lightweight effect polymorphism},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3428194},
	doi = {10.1145/3428194},
	shorttitle = {Effects as capabilities},
	abstract = {Effect handlers have recently gained popularity amongst programming language researchers. Existing type- and effect systems for effect handlers are often complicated and potentially hinder a wide-spread adoption.
            
              We present the language Effekt with the goal to close the gap between research languages with effect handlers and languages for working programmers. The design of Effekt revolves around a different view of effects and effect types. Traditionally, effect types express which
              side effects
              a computation might have. In Effekt, effect types express which
              capabilities
              a computation requires from its context. While this new point in the design space of effect systems impedes reasoning about purity, we demonstrate that it simplifies the treatment of effect polymorphism and the related issues of effect parametricity and effect encapsulation. To guarantee effect safety, we separate functions from values and treat
              all
              functions as second-class. We define the semantics of Effekt as a translation to System Xi, a calculus in explicit capability-passing style.},
	pages = {1--30},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp and Ostermann, Klaus},
	urldate = {2023-06-02},
	date = {2020-11-13},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/3TRIMRJ3/Brachthäuser et al. - 2020 - Effects as capabilities effect handlers and light.pdf:application/pdf},
}

@article{leijen_extensible_2005,
	title = {Extensible records with scoped labels},
	abstract = {Records provide a safe and ﬂexible way to construct data structures. We describe a natural approach to typing polymorphic and extensible records that is simple, easy to use in practice, and straightforward to implement. A novel aspect of this work is that records can contain duplicate labels, effectively introducing a form of scoping over the labels. Furthermore, it is a fully orthogonal extension to existing type systems and programming languages. In particular, we show how it can be used conveniently with standard {HindleyMilner}, qualiﬁed types, and {MLF}.},
	author = {Leijen, Daan},
	date = {2005-07-23},
	langid = {english},
	file = {Leijen - Extensible records with scoped labels.pdf:/home/terts/Zotero/storage/NH2Y34FP/Leijen - Extensible records with scoped labels.pdf:application/pdf},
}

@inproceedings{peyton_jones_imperative_1993,
	location = {Charleston, South Carolina, United States},
	title = {Imperative functional programming},
	isbn = {978-0-89791-560-1},
	url = {http://portal.acm.org/citation.cfm?doid=158511.158524},
	doi = {10.1145/158511.158524},
	eventtitle = {the 20th {ACM} {SIGPLAN}-{SIGACT} symposium},
	pages = {71--84},
	booktitle = {Proceedings of the 20th {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages  - {POPL} '93},
	publisher = {{ACM} Press},
	author = {Peyton Jones, Simon L. and Wadler, Philip},
	urldate = {2023-06-03},
	date = {1993},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/J62WJQS4/Peyton Jones and Wadler - 1993 - Imperative functional programming.pdf:application/pdf},
}

@article{plotkin_algebraic_2003,
	title = {Algebraic Operations and Generic Effects},
	volume = {11},
	issn = {09272852},
	url = {http://link.springer.com/10.1023/A:1023064908962},
	doi = {10.1023/A:1023064908962},
	pages = {69--94},
	number = {1},
	journaltitle = {Applied Categorical Structures},
	author = {Plotkin, Gordon and Power, John},
	urldate = {2023-06-03},
	date = {2003},
	file = {Plotkin et al. - Algebraic Operations and Generic Effects.pdf:/home/terts/Zotero/storage/DC7QZ5QF/Plotkin et al. - Algebraic Operations and Generic Effects.pdf:application/pdf},
}

@article{kiselyov_freer_2016,
	title = {Freer monads, more extensible effects},
	volume = {50},
	issn = {0362-1340, 1558-1160},
	url = {https://dl.acm.org/doi/10.1145/2887747.2804319},
	doi = {10.1145/2887747.2804319},
	abstract = {We present a rational reconstruction of extensible effects, the recently proposed alternative to monad transformers, as the confluence of efforts to make effectful computations compose. Free monads and then extensible effects emerge from the straightforward term representation of an effectful computation, as more and more boilerplate is abstracted away. The generalization process further leads to freer monads, constructed without the Functor constraint. The continuation exposed in freer monads can then be represented as an efficient type-aligned data structure. The end result is the algorithmically efficient extensible effects library, which is not only more comprehensible but also faster than earlier implementations. As an illustration of the new library, we show three surprisingly simple applications: non-determinism with committed choice ({LogicT}), catching {IO} exceptions in the presence of other effects, and the semi-automatic management of file handles and other resources through monadic regions. We extensively use and promote the new sort of `laziness', which underlies the left Kan extension: instead of performing an operation, keep its operands and pretend it is done.},
	pages = {94--105},
	number = {12},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Kiselyov, Oleg and Ishii, Hiromi},
	urldate = {2023-06-03},
	date = {2016-01-28},
	langid = {english},
	file = {Kiselyov and Ishii - Freer Monads, More Extensible Effects.pdf:/home/terts/Zotero/storage/TSE8V75R/Kiselyov and Ishii - Freer Monads, More Extensible Effects.pdf:application/pdf},
}

@article{jones_theory_1994,
	title = {A theory of qualified types},
	volume = {22},
	issn = {01676423},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0167642394000050},
	doi = {10.1016/0167-6423(94)00005-0},
	pages = {231--256},
	number = {3},
	journaltitle = {Science of Computer Programming},
	shortjournal = {Science of Computer Programming},
	author = {Jones, Mark P.},
	urldate = {2023-06-03},
	date = {1994-06},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/XZC3KDTL/Jones - 1994 - A theory of qualified types.pdf:application/pdf;Jones - A theory of qualified types.pdf:/home/terts/Zotero/storage/LQGPZB37/Jones - A theory of qualified types.pdf:application/pdf},
}

@article{bauer_what_2018,
	title = {What is algebraic about algebraic effects and handlers?},
	rights = {{arXiv}.org perpetual, non-exclusive license},
	url = {https://arxiv.org/abs/1807.05923},
	doi = {10.48550/ARXIV.1807.05923},
	abstract = {This note recapitulates and expands the contents of a tutorial on the mathematical theory of algebraic effects and handlers which I gave at the Dagstuhl seminar 18172 "Algebraic effect handlers go mainstream". It is targeted roughly at the level of a doctoral student with some amount of mathematical training, or at anyone already familiar with algebraic effects and handlers as programming concepts who would like to know what they have to do with algebra. We draw an uninterrupted line of thought between algebra and computational effects. We begin on the mathematical side of things, by reviewing the classic notions of universal algebra: signatures, algebraic theories, and their models. We then generalize and adapt the theory so that it applies to computational effects. In the last step we replace traditional mathematical notation with one that is closer to programming languages.},
	author = {Bauer, Andrej},
	urldate = {2023-06-04},
	date = {2018},
	note = {Publisher: {arXiv}
Version Number: 2},
	keywords = {08A70, {FOS}: Computer and information sciences, Logic in Computer Science (cs.{LO}), Programming Languages (cs.{PL})},
	file = {Full Text:/home/terts/Zotero/storage/XLGGM8KZ/Bauer - 2018 - What is algebraic about algebraic effects and hand.pdf:application/pdf},
}

@book{burge_recursive_1975,
	location = {Reading, Mass},
	title = {Recursive programming techniques},
	isbn = {978-0-201-14450-5},
	series = {The Systems programming series},
	pagetotal = {277},
	publisher = {Addison-Wesley Pub. Co},
	author = {Burge, William H.},
	date = {1975},
	keywords = {Combinatory logic, Recursive programming},
}

@inproceedings{schrijvers_monad_2019,
	location = {Berlin Germany},
	title = {Monad transformers and modular algebraic effects: what binds them together},
	isbn = {978-1-4503-6813-1},
	url = {https://dl.acm.org/doi/10.1145/3331545.3342595},
	doi = {10.1145/3331545.3342595},
	shorttitle = {Monad transformers and modular algebraic effects},
	eventtitle = {{ICFP} '19: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {98--113},
	booktitle = {Proceedings of the 12th {ACM} {SIGPLAN} International Symposium on Haskell},
	publisher = {{ACM}},
	author = {Schrijvers, Tom and Piróg, Maciej and Wu, Nicolas and Jaskelioff, Mauro},
	urldate = {2023-06-11},
	date = {2019-08-08},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/CMUNNZTS/Schrijvers et al. - 2019 - Monad transformers and modular algebraic effects .pdf:application/pdf},
}

@article{swierstra_data_2008,
	title = {Data types à la carte},
	volume = {18},
	issn = {0956-7968, 1469-7653},
	url = {http://www.journals.cambridge.org/abstract_S0956796808006758},
	doi = {10.1017/S0956796808006758},
	number = {4},
	journaltitle = {Journal of Functional Programming},
	shortjournal = {J. Funct. Prog.},
	author = {Swierstra, Wouter},
	urldate = {2023-06-11},
	date = {2008-07},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/PHVK4L4M/Swierstra - 2008 - Data types à la carte.pdf:application/pdf},
}

@inproceedings{brady_programming_2013,
	location = {Boston Massachusetts {USA}},
	title = {Programming and reasoning with algebraic effects and dependent types},
	isbn = {978-1-4503-2326-0},
	url = {https://dl.acm.org/doi/10.1145/2500365.2500581},
	doi = {10.1145/2500365.2500581},
	eventtitle = {{ICFP}'13: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {133--144},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {{ACM}},
	author = {Brady, Edwin},
	urldate = {2023-06-13},
	date = {2013-09-25},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/LX5AKT74/Brady - 2013 - Programming and reasoning with algebraic effects a.pdf:application/pdf},
}

@article{yang_structured_2022,
	title = {Structured Handling of Scoped Effects: Extended Version},
	rights = {Creative Commons Attribution 4.0 International},
	url = {https://arxiv.org/abs/2201.10287},
	doi = {10.48550/ARXIV.2201.10287},
	shorttitle = {Structured Handling of Scoped Effects},
	abstract = {Algebraic effects offer a versatile framework that covers a wide variety of effects. However, the family of operations that delimit scopes are not algebraic and are usually modelled as handlers, thus preventing them from being used freely in conjunction with algebraic operations. Although proposals for scoped operations exist, they are either ad-hoc and unprincipled, or too inconvenient for practical programming. This paper provides the best of both worlds: a theoretically-founded model of scoped effects that is convenient for implementation and reasoning. Our new model is based on an adjunction between a locally finitely presentable category and a category of functorial algebras. Using comparison functors between adjunctions, we show that our new model, an existing indexed model, and a third approach that simulates scoped operations in terms of algebraic ones have equal expressivity for handling scoped operations. We consider our new model to be the sweet spot between ease of implementation and structuredness. Additionally, our approach automatically induces fusion laws of handlers of scoped effects, which are useful for reasoning and optimisation.},
	author = {Yang, Zhixuan and Paviotti, Marco and Wu, Nicolas and Berg, Birthe van den and Schrijvers, Tom},
	urldate = {2023-06-13},
	date = {2022},
	note = {Publisher: {arXiv}
Version Number: 1},
	keywords = {{FOS}: Computer and information sciences, Programming Languages (cs.{PL})},
	file = {Full Text:/home/terts/Zotero/storage/U3VFUZW3/Yang et al. - 2022 - Structured Handling of Scoped Effects Extended Ve.pdf:application/pdf},
}

@online{leijen_koka_2023,
	title = {The Koka Programming Language},
	url = {https://koka-lang.github.io/koka/doc/book.html},
	author = {Leijen, Daan},
	urldate = {2023-06-13},
	date = {2023-03-15},
}

@article{xie_first-class_2022,
	title = {First-class names for effect handlers},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3563289},
	doi = {10.1145/3563289},
	abstract = {Algebraic effects and handlers are a promising technique for incorporating composable computational effects into functional programming languages. Effect handlers enable concisely programming with different effects, but they do not offer a convenient way to program with different instances of the same effect. As a solution to this inconvenience, previous studies have introduced \_named effect handlers\_, which allow the programmer to distinguish among different effect instances. However, existing formalizations of named handlers are both involved and restrictive, as they employ non-standard mechanisms to prevent the escaping of handler names.
            In this paper, we propose a simple and flexible design of named handlers. Specifically, we treat handler names as first-class values, and prevent their escaping while staying within the ordinary λ-calculus. Such a design is enabled by combining named handlers with \_scoped effects\_, a novel variation of effects that maintain a scope via rank-2 polymorphism. We formalize two combinations of named handlers and scoped effects, and implement them in the Koka programming language. We also present practical applications of named handlers, including a neural network and a unification algorithm.},
	pages = {30--59},
	issue = {{OOPSLA}2},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Xie, Ningning and Cong, Youyou and Ikemori, Kazuki and Leijen, Daan},
	urldate = {2023-06-13},
	date = {2022-10-31},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/A6I2B7DV/Xie et al. - 2022 - First-class names for effect handlers.pdf:application/pdf},
}

@article{leijen_koka_2014,
	title = {Koka: Programming with Row Polymorphic Effect Types},
	volume = {153},
	issn = {2075-2180},
	url = {http://arxiv.org/abs/1406.2061v1},
	doi = {10.4204/EPTCS.153.8},
	shorttitle = {Koka},
	pages = {100--126},
	journaltitle = {Electronic Proceedings in Theoretical Computer Science},
	shortjournal = {Electron. Proc. Theor. Comput. Sci.},
	author = {Leijen, Daan},
	urldate = {2023-06-16},
	date = {2014-06-05},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/M9WVE4MJ/Leijen - 2014 - Koka Programming with Row Polymorphic Effect Type.pdf:application/pdf},
}
