
@incollection{oh_latent_2021,
	location = {Cham},
	title = {Latent Effects for Reusable Language Components},
	volume = {13008},
	isbn = {978-3-030-89050-6 978-3-030-89051-3},
	url = {https://link.springer.com/10.1007/978-3-030-89051-3_11},
	abstract = {The development of programming languages can be quite complicated and costly. Hence, much eﬀort has been devoted to the modular deﬁnition of language features that can be reused in various combinations to deﬁne new languages and experiment with their semantics. A notable outcome of these eﬀorts is the algebra-based “datatypes `a la carte” ({DTC}) approach. When combined with algebraic eﬀects, {DTC} can model a wide range of common language features. Unfortunately, the current state of the art does not cover modular deﬁnitions of advanced control-ﬂow mechanisms that defer execution to an appropriate point, such as call-by-name and call-by-need evaluation, as well as (multi-)staging.},
	pages = {182--201},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer International Publishing},
	author = {van den Berg, Birthe and Schrijvers, Tom and Poulsen, Casper Bach and Wu, Nicolas},
	editor = {Oh, Hakjoo},
	urldate = {2023-01-12},
	date = {2021},
	langid = {english},
	doi = {10.1007/978-3-030-89051-3_11},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {van den Berg et al. - 2021 - Latent Effects for Reusable Language Components.pdf:/home/terts/Zotero/storage/42VDRB3D/van den Berg et al. - 2021 - Latent Effects for Reusable Language Components.pdf:application/pdf},
}

@incollection{swierstra_towards_2022,
	location = {Cham},
	title = {Towards a Language for Defining Reusable Programming Language Components: (Project Paper)},
	volume = {13401},
	isbn = {978-3-031-21313-7 978-3-031-21314-4},
	url = {https://link.springer.com/10.1007/978-3-031-21314-4_2},
	shorttitle = {Towards a Language for Defining Reusable Programming Language Components},
	abstract = {Developing programming languages is a diﬃcult task that requires a lot of time, eﬀort, and expertise. Reusable programming language components make this task easier, by allowing language designers to grab oﬀ-the-shelf components for common language features. Modern functional programming languages, however, lack support for reuse of deﬁnitions, and thus language components deﬁned using algebraic data types and pattern matching functions cannot be reused without modifying or copying existing code. To improve the situation, we introduce {CS}, a functional meta-language for developing reusable programming language components, that features built-in support for extensible data types and functions, as well as eﬀects and handlers. In {CS}, we can deﬁne language components using algebraic data types and pattern matching functions, such that we can compose language components into larger languages and deﬁne new interpretations for existing components without modifying existing deﬁnitions.},
	pages = {18--38},
	booktitle = {Trends in Functional Programming},
	publisher = {Springer International Publishing},
	author = {van der Rest, Cas and Poulsen, Casper Bach},
	editor = {Swierstra, Wouter and Wu, Nicolas},
	urldate = {2023-01-12},
	date = {2022},
	langid = {english},
	doi = {10.1007/978-3-031-21314-4_2},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {van der Rest and Poulsen - 2022 - Towards a Language for Defining Reusable Programmi.pdf:/home/terts/Zotero/storage/MYYD7MQA/van der Rest and Poulsen - 2022 - Towards a Language for Defining Reusable Programmi.pdf:application/pdf},
}

@misc{van_der_rest_handling_2022,
	title = {Handling Higher-Order Effects},
	url = {http://arxiv.org/abs/2203.03288},
	abstract = {Algebraic effect handlers is a programming paradigm where programmers can declare their own syntactic operations, and modularly define the semantics of these using effect handlers. However, we cannot directly define algebraic effect handlers for many higher-order operations (or higher-order effects) -- i.e., operations that have computations as parameters. Examples of such higher-order effects include common programming features, such as try-catch exception handlers, function abstraction, and more. In this paper we present a new kind of effect handler that addresses this shortcoming. Our effect handler approach is closely related to previous work on scoped effect handlers, which also supports higher-order effects. A key difference is that our effect handlers make it easy to understand separate (higher-order) effects as separate concerns, since effects do not interact. In contrast, effect interaction is the default with scoped effect handlers. While separate concerns is the default with our handlers, it is also possible to define handlers where effects interact.},
	number = {{arXiv}:2203.03288},
	publisher = {{arXiv}},
	author = {van der Rest, Cas and Reinders, Jaro and Poulsen, Casper Bach},
	urldate = {2023-01-12},
	date = {2022-03-07},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2203.03288 [cs]},
	keywords = {Computer Science - Programming Languages, F.3.2},
	file = {van der Rest et al. - 2022 - Handling Higher-Order Effects.pdf:/home/terts/Zotero/storage/WTQMFDSS/van der Rest et al. - 2022 - Handling Higher-Order Effects.pdf:application/pdf},
}

@incollection{drossopoulou_sound_2008,
	location = {Berlin, Heidelberg},
	title = {A Sound Semantics for {OCaml} light},
	volume = {4960},
	isbn = {978-3-540-78738-9 978-3-540-78739-6},
	url = {http://link.springer.com/10.1007/978-3-540-78739-6_1},
	abstract = {Few programming languages have a mathematically rigorous deﬁnition or metatheory—in part because they are perceived as too large and complex to work with. This paper demonstrates the feasibility of such undertakings: we formalize a substantial portion of the semantics of Objective Caml’s core language (which had not previously been given a formal semantics), and we develop a mechanized type soundness proof in {HOL}. We also develop an executable version of the operational semantics, verify that it coincides with our semantic definition, and use it to test conformance between the semantics and the {OCaml} implementation. We intend our semantics to be a suitable substrate for the veriﬁcation of {OCaml} programs.},
	pages = {1--15},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Owens, Scott},
	editor = {Drossopoulou, Sophia},
	urldate = {2023-01-12},
	date = {2008},
	langid = {english},
	doi = {10.1007/978-3-540-78739-6_1},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Owens - 2008 - A Sound Semantics for OCaml light.pdf:/home/terts/Zotero/storage/ZHK3FQJ2/Owens - 2008 - A Sound Semantics for OCaml light.pdf:application/pdf},
}

@article{moggi_notions_1991,
	title = {Notions of computation and monads},
	volume = {93},
	issn = {08905401},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0890540191900524},
	doi = {10.1016/0890-5401(91)90052-4},
	pages = {55--92},
	number = {1},
	journaltitle = {Information and Computation},
	shortjournal = {Information and Computation},
	author = {Moggi, Eugenio},
	urldate = {2023-01-12},
	date = {1991-07},
	langid = {english},
	file = {Moggi - 1991 - Notions of computation and monads.pdf:/home/terts/Zotero/storage/Q6F6S9LG/Moggi - 1991 - Notions of computation and monads.pdf:application/pdf},
}

@article{plotkin_handling_2013,
	title = {Handling Algebraic Effects},
	volume = {9},
	issn = {18605974},
	url = {https://lmcs.episciences.org/705},
	doi = {10.2168/LMCS-9(4:23)2013},
	abstract = {Algebraic eﬀects are computational eﬀects that can be represented by an equational theory whose operations produce the eﬀects at hand. The free model of this theory induces the expected computational monad for the corresponding eﬀect. Algebraic eﬀects include exceptions, state, nondeterminism, interactive input/output, and time, and their combinations. Exception handling, however, has so far received no algebraic treatment.},
	pages = {23},
	number = {4},
	journaltitle = {Logical Methods in Computer Science},
	shortjournal = {Log.Meth.Comput.Sci.},
	author = {Plotkin, Gordon and Pretnar, Matija},
	editor = {Tarlecki, Andrzej},
	urldate = {2023-01-12},
	date = {2013-12-17},
	langid = {english},
	file = {Plotkin and Pretnar - 2013 - Handling Algebraic Effects.pdf:/home/terts/Zotero/storage/Z63I7A89/Plotkin and Pretnar - 2013 - Handling Algebraic Effects.pdf:application/pdf},
}

@misc{wu_effect_2014,
	title = {Effect Handlers in Scope},
	abstract = {Algebraic effect handlers are a powerful means for describing effectful computations. They provide a lightweight and orthogonal technique to define and compose the syntax and semantics of different effects. The semantics is captured by handlers, which are functions that transform syntax trees. Unfortunately, the approach does not support syntax for scoping constructs, which arise in a number of scenarios. While handlers can be used to provide a limited form of scope, we demonstrate that this approach constrains the possible interactions of effects and rules out some desired semantics. This paper presents two different ways to capture scoped constructs in syntax, and shows how to achieve different semantics by reordering handlers. The first approach expresses scopes using the existing algebraic handlers framework, but has some limitations. The problem is fully solved in the second approach where we introduce higher-order syntax.},
	author = {Wu, Nicolas and Schrijvers, Tom and Hinze, Ralf},
	date = {2014-06-10},
	file = {Wu et al. - 2014 - Effect Handlers in Scope.pdf:/home/terts/Zotero/storage/Y2CYJ9RV/Wu et al. - 2014 - Effect Handlers in Scope.pdf:application/pdf},
}

@article{pretnar_introduction_2015,
	title = {An Introduction to Algebraic Effects and Handlers. Invited tutorial paper},
	volume = {319},
	issn = {15710661},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1571066115000705},
	doi = {10.1016/j.entcs.2015.12.003},
	abstract = {This paper is a tutorial on algebraic eﬀects and handlers. In it, we explain what algebraic eﬀects are, give ample examples to explain how handlers work, deﬁne an operational semantics and a type \& eﬀect system, show how one can reason about eﬀects, and give pointers for further reading.},
	pages = {19--35},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Pretnar, Matija},
	urldate = {2023-01-12},
	date = {2015-12},
	langid = {english},
	file = {Pretnar - 2015 - An Introduction to Algebraic Effects and Handlers..pdf:/home/terts/Zotero/storage/6JHDDVP8/Pretnar - 2015 - An Introduction to Algebraic Effects and Handlers..pdf:application/pdf},
}

@article{kiselyov_freer_nodate,
	title = {Freer Monads, More Extensible Effects},
	abstract = {We present a rational reconstruction of extensible effects, the recently proposed alternative to monad transformers, as the conﬂuence of efforts to make effectful computations compose. Free monads and then extensible effects emerge from the straightforward term representation of an effectful computation, as more and more boilerplate is abstracted away. The generalization process further leads to freer monads, constructed without the Functor constraint. The continuation exposed in freer monads can then be represented as an efﬁcient type-aligned data structure. The end result is the algorithmically efﬁcient extensible effects library, which is not only more comprehensible but also faster than earlier implementations.},
	author = {Kiselyov, Oleg and Ishii, Hiromi},
	langid = {english},
	file = {Kiselyov and Ishii - Freer Monads, More Extensible Effects.pdf:/home/terts/Zotero/storage/TSE8V75R/Kiselyov and Ishii - Freer Monads, More Extensible Effects.pdf:application/pdf},
}

@article{plotkin_algebraic_nodate,
	title = {Algebraic Operations and Generic Effects},
	abstract = {Given a complete and cocomplete symmetric monoidal closed category V and a symmetric monoidal V-category C with cotensors and a strong V-monad T on C, we investigate axioms under which an Ob C-indexed family of operations of the form αx : (T x)v → (T x)w provides semantics for algebraic operations on the computational λ-calculus. We recall a deﬁnition for which we have elsewhere given adequacy results, and we show that an enrichment of it is equivalent to a range of other possible natural deﬁnitions of algebraic operation. In particular, we deﬁne the notion of generic effect and show that to give a generic effect is equivalent to giving an algebraic operation. We further show how the usual monadic semantics of the computational λ-calculus extends uniformly to incorporate generic effects. We outline examples and non-examples and we show that our deﬁnition also enriches one for call-by-name languages with effects.},
	author = {Plotkin, Gordon and Power, John and Moggi, Eugenio},
	langid = {english},
	file = {Plotkin et al. - Algebraic Operations and Generic Effects.pdf:/home/terts/Zotero/storage/DC7QZ5QF/Plotkin et al. - Algebraic Operations and Generic Effects.pdf:application/pdf},
}

@inproceedings{kammar_handlers_2013,
	location = {Boston Massachusetts {USA}},
	title = {Handlers in action},
	isbn = {978-1-4503-2326-0},
	url = {https://dl.acm.org/doi/10.1145/2500365.2500590},
	doi = {10.1145/2500365.2500590},
	eventtitle = {{ICFP}'13: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {145--158},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {{ACM}},
	author = {Kammar, Ohad and Lindley, Sam and Oury, Nicolas},
	urldate = {2023-01-18},
	date = {2013-09-25},
	langid = {english},
	file = {Kammar et al. - 2013 - Handlers in action.pdf:/home/terts/Zotero/storage/NTEZTXGD/Kammar et al. - 2013 - Handlers in action.pdf:application/pdf},
}

@article{bach_poulsen_hefty_2023,
	title = {Hefty Algebras: Modular Elaboration of Higher-Order Algebraic Effects},
	volume = {7},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3571255},
	doi = {10.1145/3571255},
	shorttitle = {Hefty Algebras},
	abstract = {Algebraic effects and handlers is an increasingly popular approach to programming with effects. An attraction of the approach is its modularity: effectful programs are written against an interface of declared operations, which allows the implementation of these operations to be defined and refined without changing or recompiling programs written against the interface. However, higher-order operations (i.e., operations that take computations as arguments) break this modularity. While it is possible to encode higher-order operations by elaborating them into more primitive algebraic effects and handlers, such elaborations are typically not modular. In particular, operations defined by elaboration are typically not a part of any effect interface, so we cannot define and refine their implementation without changing or recompiling programs. To resolve this problem, a recent line of research focuses on developing new and improved effect handlers. In this paper we present a (surprisingly) simple alternative solution to the modularity problem with higher-order operations:  
we modularize the previously non-modular elaborations commonly used to encode higher-order operations. Our solution is as expressive as the state of the art in effects and handlers.},
	pages = {1801--1831},
	issue = {{POPL}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Bach Poulsen, Casper and van der Rest, Cas},
	urldate = {2023-01-26},
	date = {2023-01-09},
	langid = {english},
	file = {Bach Poulsen and van der Rest - 2023 - Hefty Algebras Modular Elaboration of Higher-Orde.pdf:/home/terts/Zotero/storage/FEZCDW6F/Bach Poulsen and van der Rest - 2023 - Hefty Algebras Modular Elaboration of Higher-Orde.pdf:application/pdf},
}

@article{jones_theory_nodate,
	title = {A theory of qualified types},
	author = {Jones, Mark P},
	langid = {english},
	file = {Jones - A theory of qualified types.pdf:/home/terts/Zotero/storage/LQGPZB37/Jones - A theory of qualified types.pdf:application/pdf},
}

@article{bauer_programming_2015,
	title = {Programming with algebraic effects and handlers},
	volume = {84},
	issn = {23522208},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S2352220814000194},
	doi = {10.1016/j.jlamp.2014.02.001},
	abstract = {Eff is a programming language based on the algebraic approach to computational effects, in which effects are viewed as algebraic operations and effect handlers as homomorphisms from free algebras. Eff supports ﬁrst-class effects and handlers through which we may easily deﬁne new computational effects, seamlessly combine existing ones, and handle them in novel ways. We give a denotational semantics of Eff and discuss a prototype implementation based on it. Through examples we demonstrate how the standard effects are treated in Eff, and how Eff supports programming techniques that use various forms of delimited continuations, such as backtracking, breadth-ﬁrst search, selection functionals, cooperative multi-threading, and others.},
	pages = {108--123},
	number = {1},
	journaltitle = {Journal of Logical and Algebraic Methods in Programming},
	shortjournal = {Journal of Logical and Algebraic Methods in Programming},
	author = {Bauer, Andrej and Pretnar, Matija},
	urldate = {2023-04-03},
	date = {2015-01},
	langid = {english},
	file = {Bauer and Pretnar - 2015 - Programming with algebraic effects and handlers.pdf:/home/terts/Zotero/storage/FW43SCRE/Bauer and Pretnar - 2015 - Programming with algebraic effects and handlers.pdf:application/pdf},
}

@thesis{pretnar_logic_2010,
	title = {The Logic and Handling of Algebraic Effects},
	institution = {The University of Edinburgh},
	type = {phdthesis},
	author = {Pretnar, Matija},
	date = {2010},
	langid = {english},
	file = {Pretnar - The Logic and Handling of Algebraic Effects.pdf:/home/terts/Zotero/storage/IMU34MMC/Pretnar - The Logic and Handling of Algebraic Effects.pdf:application/pdf},
}

@inproceedings{moggi_computational_1989,
	location = {Pacific Grove, {CA}, {USA}},
	title = {Computational lambda-calculus and monads},
	isbn = {978-0-8186-1954-0},
	url = {http://ieeexplore.ieee.org/document/39155/},
	doi = {10.1109/LICS.1989.39155},
	abstract = {The λ-calculus is considered an useful mathematical tool in the study of programming languages. However, if one uses βη-conversion to prove equivalence of programs, then a gross simpliﬁcation1 is introduced. We give a calculus based on a categorical semantics for computations, which provides a correct basis for proving equivalence of programs, independent from any speciﬁc computational model.},
	eventtitle = {[1989] Proceedings. Fourth Annual Symposium on Logic in Computer Science},
	pages = {14--23},
	booktitle = {[1989] Proceedings. Fourth Annual Symposium on Logic in Computer Science},
	publisher = {{IEEE} Comput. Soc. Press},
	author = {Moggi, E.},
	urldate = {2023-04-08},
	date = {1989},
	langid = {english},
	file = {Moggi - 1989 - Computational lambda-calculus and monads.pdf:/home/terts/Zotero/storage/56LWTKNU/Moggi - 1989 - Computational lambda-calculus and monads.pdf:application/pdf},
}

@incollection{goos_adequacy_2001,
	location = {Berlin, Heidelberg},
	title = {Adequacy for Algebraic Effects},
	volume = {2030},
	isbn = {978-3-540-41864-1 978-3-540-45315-4},
	url = {http://link.springer.com/10.1007/3-540-45315-6_1},
	abstract = {Moggi proposed a monadic account of computational eﬀects. He also presented the computational λ-calculus, λc, a core call-by-value functional programming language for eﬀects; the eﬀects are obtained by adding appropriate operations. The question arises as to whether one can give a corresponding treatment of operational semantics. We do this in the case of algebraic eﬀects where the operations are given by a single-sorted algebraic signature, and their semantics is supported by the monad, in a certain sense. We consider call-by-value {PCF} with—and without—recursion, an extension of λc with arithmetic. We prove general adequacy theorems, and illustrate these with two examples: nondeterminism and probabilistic nondeterminism.},
	pages = {1--24},
	booktitle = {Foundations of Software Science and Computation Structures},
	publisher = {Springer Berlin Heidelberg},
	author = {Plotkin, Gordon and Power, John},
	editor = {Honsell, Furio and Miculan, Marino},
	editorb = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan},
	editorbtype = {redactor},
	urldate = {2023-04-08},
	date = {2001},
	langid = {english},
	doi = {10.1007/3-540-45315-6_1},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Plotkin and Power - 2001 - Adequacy for Algebraic Effects.pdf:/home/terts/Zotero/storage/BD3ME4NL/Plotkin and Power - 2001 - Adequacy for Algebraic Effects.pdf:application/pdf},
}

@incollection{castagna_handlers_2009,
	location = {Berlin, Heidelberg},
	title = {Handlers of Algebraic Effects},
	volume = {5502},
	isbn = {978-3-642-00589-3 978-3-642-00590-9},
	url = {http://link.springer.com/10.1007/978-3-642-00590-9_7},
	pages = {80--94},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer Berlin Heidelberg},
	author = {Plotkin, Gordon and Pretnar, Matija},
	editor = {Castagna, Giuseppe},
	urldate = {2023-04-08},
	date = {2009},
	doi = {10.1007/978-3-642-00590-9_7},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Accepted Version:/home/terts/Zotero/storage/QSC9N5WD/Plotkin and Pretnar - 2009 - Handlers of Algebraic Effects.pdf:application/pdf},
}

@misc{lindley_be_2017,
	title = {Do be do be do},
	url = {http://arxiv.org/abs/1611.09259},
	abstract = {We explore the design and implementation of Frank, a strict functional programming language with a bidirectional effect type system designed from the ground up around a novel variant of Plotkin and Pretnar’s effect handler abstraction.},
	number = {{arXiv}:1611.09259},
	publisher = {{arXiv}},
	author = {Lindley, Sam and {McBride}, Conor and {McLaughlin}, Craig},
	urldate = {2023-04-08},
	date = {2017-10-03},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1611.09259 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {Lindley et al. - 2017 - Do be do be do.pdf:/home/terts/Zotero/storage/HVDS8XC9/Lindley et al. - 2017 - Do be do be do.pdf:application/pdf},
}

@inproceedings{leijen_type_2017,
	location = {Paris France},
	title = {Type directed compilation of row-typed algebraic effects},
	isbn = {978-1-4503-4660-3},
	url = {https://dl.acm.org/doi/10.1145/3009837.3009872},
	doi = {10.1145/3009837.3009872},
	eventtitle = {{POPL} '17: The 44th Annual {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	pages = {486--499},
	booktitle = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Leijen, Daan},
	urldate = {2023-04-08},
	date = {2017-01},
	langid = {english},
	file = {Leijen - Type Directed Compilation of Row-Typed Algebraic E.pdf:/home/terts/Zotero/storage/GYJ3MYKX/Leijen - Type Directed Compilation of Row-Typed Algebraic E.pdf:application/pdf},
}

@inproceedings{sivaramakrishnan_retrofitting_2021,
	title = {Retrofitting Effect Handlers onto {OCaml}},
	url = {http://arxiv.org/abs/2104.00250},
	doi = {10.1145/3453483.3454039},
	abstract = {Effect handlers have been gathering momentum as a mechanism for modular programming with user-defined effects. Effect handlers allow for non-local control flow mechanisms such as generators, async/await, lightweight threads and coroutines to be composably expressed. We present a design and evaluate a full-fledged efficient implementation of effect handlers for {OCaml}, an industrial-strength multi-paradigm programming language. Our implementation strives to maintain the backwards compatibility and performance profile of existing {OCaml} code. Retrofitting effect handlers onto {OCaml} is challenging since {OCaml} does not currently have any nonlocal control flow mechanisms other than exceptions. Our implementation of effect handlers for {OCaml}: (i) imposes a mean 1\% overhead on a comprehensive macro benchmark suite that does not use effect handlers; (ii) remains compatible with program analysis tools that inspect the stack; and (iii) is efficient for new code that makes use of effect handlers.},
	pages = {206--221},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} International Conference on Programming Language Design and Implementation},
	author = {Sivaramakrishnan, K. C. and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
	urldate = {2023-04-08},
	date = {2021-06-19},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2104.00250 [cs]},
	keywords = {Computer Science - Programming Languages, D.3.3},
	file = {Sivaramakrishnan et al. - 2021 - Retrofitting Effect Handlers onto OCaml.pdf:/home/terts/Zotero/storage/GPMXK3JR/Sivaramakrishnan et al. - 2021 - Retrofitting Effect Handlers onto OCaml.pdf:application/pdf},
}
